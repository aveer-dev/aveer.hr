create table "public"."waitlist" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "email" text not null,
    "source" text not null
);
alter table "public"."waitlist" enable row level security;
CREATE UNIQUE INDEX waitlist_email_key ON public.waitlist USING btree (email);
CREATE UNIQUE INDEX waitlist_pkey ON public.waitlist USING btree (id);
alter table "public"."waitlist" add constraint "waitlist_pkey" PRIMARY KEY using index "waitlist_pkey";
alter table "public"."waitlist" add constraint "waitlist_email_key" UNIQUE using index "waitlist_email_key";
set check_function_bodies = off;
CREATE OR REPLACE FUNCTION public.authorize_role(org_name text)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$DECLARE
  bind_role int;
  user_role public.app_role;
  user_role_org text;
BEGIN
  -- Fetch user role and organization from JWT
  SELECT (auth.jwt() ->> 'user_role')::public.app_role INTO user_role;
  SELECT (auth.jwt() ->> 'user_role_org')::text INTO user_role_org;

  -- Return false if user_role_org is null or empty
  IF user_role_org IS NULL OR user_role_org = '' THEN
    RETURN false;
  END IF;

  -- If user_role_org does not match org_name, check profiles_roles table
  IF LOWER(user_role_org) != LOWER(org_name) THEN
    SELECT COUNT(*)
    INTO bind_role
    FROM public.profiles_roles
    WHERE profiles_roles.organisation = org_name
      AND profiles_roles.role = 'admin'  -- Check if role is 'admin'
      AND profiles_roles.profile = auth.uid()
      AND profiles_roles.disable = false;  -- Check if disable is false

    RETURN bind_role > 0;
  END IF;

  -- If user_role_org matches org_name, return true
  RETURN true;
END;$function$;
grant delete on table "public"."waitlist" to "anon";
grant insert on table "public"."waitlist" to "anon";
grant references on table "public"."waitlist" to "anon";
grant select on table "public"."waitlist" to "anon";
grant trigger on table "public"."waitlist" to "anon";
grant truncate on table "public"."waitlist" to "anon";
grant update on table "public"."waitlist" to "anon";
grant delete on table "public"."waitlist" to "authenticated";
grant insert on table "public"."waitlist" to "authenticated";
grant references on table "public"."waitlist" to "authenticated";
grant select on table "public"."waitlist" to "authenticated";
grant trigger on table "public"."waitlist" to "authenticated";
grant truncate on table "public"."waitlist" to "authenticated";
grant update on table "public"."waitlist" to "authenticated";
grant delete on table "public"."waitlist" to "service_role";
grant insert on table "public"."waitlist" to "service_role";
grant references on table "public"."waitlist" to "service_role";
grant select on table "public"."waitlist" to "service_role";
grant trigger on table "public"."waitlist" to "service_role";
grant truncate on table "public"."waitlist" to "service_role";
grant update on table "public"."waitlist" to "service_role";
create policy "Enable read access for all users"
on "public"."organisations"
as permissive
for select
to public
using (true);
create policy "Allow public insert"
on "public"."waitlist"
as permissive
for insert
to public
with check (true);
